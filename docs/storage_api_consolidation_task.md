# План консолидации API и целостности данных хранилища

Документ описывает текущее состояние сервиса хранения, ключевые проблемы и пошаговый план работ. Формат подобран так, чтобы любой разработчик (или другая LLM) мог безболезненно подхватить процесс, понять, что уже сделано, и какие шаги предстоят.

## 1. Контекст и цели

- Legacy-операции работают через поле `Sample.storage` (`assign_cell`, `clear_cell`, `bulk-assign`), новая логика — через `SampleStorageAllocation` (`allocate_cell`, `unallocate_cell`, `bulk-allocate`). Разделение порождает дублирование и риски несогласованных данных.
- API `/api/storage/`, `/api/storage/summary/`, `/api/storage/boxes/{box_id}/detail/` вычисляют показатели разными способами. При неполных данных ответы расходятся.
- В справочниках одновременно живут устаревшие `/api/reference/` и актуальные `/api/reference-data/`.
- Бизнес-логика распределена по вью без явного сервисного слоя; транзакции и инварианты сложно контролировать.

**Цель:** привести модели к консистентному виду, сконцентрировать логику в одном слое, унифицировать API и обеспечить поэтапный переход фронтенда/интеграций с сохранением прозрачности прогресса.

## 2. Основные проблемы

1. **Неоднородные данные.** Не для всех `box_id` заведены `StorageBox`, число строк в `Storage` не всегда равно `rows * cols`.
2. **Фрагментированная логика.** Legacy и новая реализация дублируют поведение и усложняют транзакционный контроль.
3. **Несогласованные ответы API.** Разные эндпоинты опираются на разную логику агрегации.
4. **Нет дорожной карты депрекации.** Клиенты продолжают использовать устаревшие ручки без предупреждений и расписания отключения.
5. **Нет регулярной проверки целостности.** Отсутствуют автоматические проверки инвариантов (полноты ячеек, дубликатов, др.).

## 3. Пошаговый план

Каждый этап завершается проверками и фиксацией результата. Чекбоксы помогают отслеживать прогресс. Комментарии под пунктами содержат даты/детали выполненных действий.

### Этап 0. Подготовка и аудит

- [x] Собрать текущее состояние БД: список всех `StorageBox`, `Storage`, статистику по расхождениям (`rows/cols` vs фактические ячейки).
  - Скрипт `backend/scripts/audit_storage_state.py` (запуск: `python manage.py shell --command "exec(open('scripts/audit_storage_state.py').read())"`). Срез на 27.10.2025: 23 уникальных бокса, у 21 отсутствовали метаданные, 7 боксов имели пропуски ячеек.
- [x] Зафиксировать версии зависимых сервисов (фронтенд, интеграции), порядок вызова API, существующие cron/скрипты.
  - Фронтенд (`frontend/package.json`): React `^19.1.0`, React Query `^5.90.2`, Vite `^6.3.5`, Vitest `^3.2.4`.
  - Бекенд (`backend/requirements.txt`): Django `4.2.x`, DRF `3.14+`, DRF Spectacular `0.27+`, Pydantic `2.5+`. Cron/скриптов в репозитории нет; уточнения у ops не выявили запланированных задач.
  - Интеграции: внешний список пока не формализован; TODO перенесён на Этап 5 (документация).
- [x] Составить собственное расписание депрекации и обновлений.
  - Разработчик один, поэтому согласование не требуется. Драфт: предупреждения добавляем на Этапе 3, фронт переключаем на новых ручки на Этапе 4, legacy отключаем после успешного регресса (ориентир — +2 итерации).

**Выход:** зафиксированное состояние БД, версии зависимостей и внутренний roadmap по депрекации.

### Этап 1. Восстановление целостности данных

- [x] Добавить недостающие записи `StorageBox` и корректные `rows/cols` (через миграцию или управляемый скрипт).
  - 27.10.2025: выполнена команда `python manage.py ensure_storage_consistency`, создано 21 недостающее описание боксов (ID 2–22).
- [x] Прогнать `ensure_storage_cells` для всех боксов, устранить дубликаты и заполнить пропуски в таблице `Storage`.
  - Команда `ensure_storage_consistency` автоматически вызвала `ensure_storage_cells`; заполнены 7 пропусков (боксы 4, 5, 7, 8, 10 и др.). Повторный аудит подтвердил отсутствие дыр/дубликатов.
- [x] Добавить автоматический скрипт/management-команду для проверки инвариантов (`rows*cols == unique cell count`, отсутствие «дыр»).
  - Реализована management-команда `storage_management.management.commands.ensure_storage_consistency` (поддерживает `--dry-run`, `--json`, фильтрацию по `--box`). Используется как инструмент восстановления и периодической проверки.
- [x] Настроить периодический запуск проверки (CI или cron) с уведомлением о нарушениях.
  - 28.10.2025: добавлен workflow `.github/workflows/storage-consistency.yml` (ежедневно в 06:00 МСК + ручной `workflow_dispatch`), для работы нужны секреты `STORAGE_CONSISTENCY_DB_HOST/PORT/NAME/USER/PASSWORD` и (опционально) `STORAGE_CONSISTENCY_SLACK_WEBHOOK`. Скрипт запускает `python manage.py ensure_storage_consistency --dry-run --json`, сохраняет отчёт, валидирует наличие изменений и, при проблемах, присылает уведомление в Slack и завершает job с ошибкой. Если секреты не заданы, job пропускается с зелёным статусом.
- [x] Написать юнит/интеграционные тесты на инварианты.
  - Добален класс `StorageConsistencyCommandTests` в `backend/storage_management/tests.py`; прогон `python manage.py test storage_management.tests.StorageConsistencyCommandTests` проходит, покрывая создание метаданных, обновление геометрии и dry-run.

**Выход:** база приведена к консистентному виду, есть инструмент для повторного прогона и тесты, фиксирующие инварианты.

### Этап 2. Консолидация бизнес-логики и транзакций

- [x] Перенести операции с ячейками в сервисный слой (`storage_management/services.py`) с использованием `transaction.atomic()` и `select_for_update()`.
- [x] Обновить API-вью, чтобы они вызывали только сервисные функции (без прямой работы с моделями).
- [x] Добавить тесты на конкурентные сценарии (параллельное распределение, освобождение ячеек).
  - 28.10.2025: добавлены API-тесты StorageAPITests для проверок логирования и ошибок StorageServiceError; реализованы StorageServiceConcurrencyTests с параллельным размещением/аллокацией (через потоки и барьер), что покрывает гонки на ячейки. Дополнительно стоит рассмотреть нагрузочные сценарии в будущем.
- [x] Провести код-ревью/договориться о правилах: изменять данные только через сервисный слой.
  - 28.10.2025: подготовлен документ `docs/storage_service_guidelines.md` с правилами транзакций, логирования и чек-листом для ревью; все дальнейшие изменения хранилища проходят через сервисный слой.

**Выход:** единая точка входа, транзакционная целостность подтверждена тестами.

### Этап 3. Консолидация API (бекенд)

- [x] Выравнять ответы `storage_overview`, `storage_summary`, `storage_box_details`, `get_box_cells`, переиспользуя общие расчёты.
  - 28.10.2025: добавлен сервис build_storage_snapshot; overview/summary/details/cells работают на одном снимке.
- [x] Для `assign_cell`, `clear_cell`, `bulk-assign` добавить явные предупреждения (`Deprecation`) и логирование.
  - 28.10.2025: _mark_legacy_deprecated добавляет заголовки и логирует обращения к legacy ручкам.
- [x] Реализовать аналогичный функционал через `allocate_cell` с `is_primary=true`, `unallocate_cell`, `bulk-allocate`.
  - 28.10.2025: актуальные ручки подключены к сервисному слою, legacy переиспользуют его же.
- [x] Обновить `urls.py`, документацию Swagger/OpenAPI (`drf_spectacular`), `API_BOXES_DOCUMENTATION.md`.
  - 28.10.2025: extend_schema(deprecated=True) и обновление API_BOXES_DOCUMENTATION.md описывают снимок и legacy статус.
- [x] Настроить мониторинг обращений к legacy ручкам.
  - 28.10.2025: предупреждения в логах по каждому вызову; можно собирать метрики по заголовкам ответа.

**Выход:** актуальные API-эндпоинты покрывают весь функционал, legacy контролируются и готовы к отключению.

### Этап 4. Обновление клиентов (фронтенд и интеграции)

- [x] Перевести `frontend/src/pages/Storage.tsx` и связанные сервисы на новые ручки (`allocate/unallocate`), использовать согласованные агрегаты.
- [x] Удалить временные слияния данных (`summaryResp` vs `getBoxes`) — фронт теперь полагается на snapshot `storage_overview`.
- [x] Добавить предупреждения о депрекации (toast/banner) и fallback-поведение при необходимости. → Реализован перехват `X-Endpoint-Deprecated` в `apiService` и глобальный хук `useDeprecatedEndpointAlerts`; сообщения показываются через `ToastProvider`, повторения дедуплированы на сессию.
- [ ] Обновить компоненты и проверки:
  - [x] `StorageManager`
  - [x] `StorageMultiAssign`
  - [x] `EditSampleForm` (переход на allocate/unallocate)
  - [x] e2e-тесты (`frontend/e2e/storage-page.spec.ts`): добавлен сценарий с замоканными snapshot/деталями для проверки новых API.
- [x] Проверить внешние интеграции и обновить их вызовы. → Проведён поиск по репозиторию; отрефакторен `backend/debug_sample_56_api.py` на использование `/api/storage/` и `/cells/` вместо legacy `/free`/`free-cells`.

**Выход:** клиенты работают только с новым API, отображают согласованные данные.

### Этап 5. Документация и обучение

- [x] Обновить README, `API_BOXES_DOCUMENTATION.md`, wiki/Confluence с новой схемой. → README дополнили блоком *Storage toolkit*, `API_BOXES_DOCUMENTATION.md` описывает `/api/storage/...` и заголовки депрекации.
- [x] Добавить инструкции по проверке целостности, работе с сервисным слоем, плану депрекации. → `API_BOXES_DOCUMENTATION.md` и `storage_service_guidelines.md` теперь содержат команды `ensure_storage_consistency`/`audit_storage_state.py` и правила обработки `StorageServiceError`.
- [ ] Провести внутреннее демо / собрать обратную связь. → TODO: подготовить 15‑минутный walkthrough для команды (см. черновик сценария в Confluence).
- [ ] Подготовить внешние release notes (если требуется).

**Выход:** знания задокументированы, команда понимает новые процессы.

### Этап 6. Контроль и сопровождение

- [ ] Включить проверки целостности и smoke-тесты в CI/CD.
- [ ] Настроить мониторинг ключевых метрик (занятость ячеек, ошибки API) и алерты.
- [ ] Регулярно пересматривать план работ и актуализировать документ по мере изменений.

**Выход:** качество данных поддерживается автоматически, отклонения фиксируются оперативно.

## 4. Дополнительные рекомендации

- Фиксировать прогресс прямо в этом документе (чекбоксы, подпункты с датами).
- При передаче задачи новой LLM оставлять краткое резюме сделанных шагов и ссылку на релевантные команды/скрипты.
- Поддерживать скрипты `audit_storage_state.py` и `ensure_storage_consistency` синхронно: аудит использует данные, которые генерирует команда восстановления.

---

**Текущее состояние:** Этап 0 выполнен, на Этапе 1 закрыты 4/5 задач (осталось автоматизировать запуск проверки). Дальнейшие шаги — переход к Этапу 2 и настройка периодического аудита.
