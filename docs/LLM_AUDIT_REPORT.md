### Анализ проблем и рекомендации

#### **1. Выявленные проблемы**
- Дублирование модели `ChangeLog` в двух приложениях: `audit_logging/models.py` (`db_table="audit_changelog"`, именные индексы) и `collection_manager/models.py` (`db_table="changelog"`, без именных индексов). Это нарушает DRY и несёт риск расхождения схем/индексов и разных точек записи.
- Устаревшие миграции `collection_manager/migrations/0001_initial.py` создают конфликтующие таблицы и модели (`IndexLetter`, `Location`, `Source`, `Strain`, `Storage`, `Sample`), не соответствующие актуальным моделям из `reference_data`, `sample_management`, `storage_management`, `strain_management`. Применение этих миграций приведёт к дублированию и несовместимости схемы.
- Ошибки и риски в API-логике:
  - Неверное значение `content_type` при логировании в `storage_management/api.py`: используется `'Sample'` (с заглавной), допустимые значения — `'sample' | 'strain' | 'storage'`.
  - Дублирующее добавление связей `SampleGrowthMedia` в `collection_manager/api.py` при создании образца (двойной цикл), риск `IntegrityError` из-за `unique_together`.
  - Массовое размещение образцов по ячейкам (`bulk_assign_cells`) без транзакционной блокировки/конкурентных гарантий — возможны гонки и двойное назначение ячейки.

#### **2. Предложенные решения**
- **Решение для дублирования модели ChangeLog:**
  Централизовать `ChangeLog` в `audit_logging` и использовать единую модель во всех местах.
  - Заменить импорты на `audit_logging.models.ChangeLog` (например, в `collection_manager/utils.py`, `collection_manager/admin.py`, вызовы из API).
  - Добавить нормализацию `content_type` в утилите логирования: принудительный `.lower()` и проверка допустимых значений (`{"sample","strain","storage"}`). 
  - При наличии данных в `changelog` выполнить миграцию в `audit_changelog` и после этого удалить дубликат модели и регистрацию в админке.
  - Сохранить именные индексы из `audit_logging` как единый стандарт.

- **Решение для устаревших миграций collection_manager:**
  Исключить конфликтующие миграции из контура продакшн-схемы и согласовать приложение `collection_manager` как интеграционный слой без собственных моделей.
  - Пересмотреть/удалить `collection_manager/migrations/0001_initial.py` (варианты: squash/fake) так, чтобы не создавались дублирующие таблицы.
  - Обеспечить зависимость на актуальные модели из специализированных приложений (`reference_data`, `sample_management`, `storage_management`, `strain_management`).
  - Задокументировать стратегию миграций и порядок применения в окружениях.

- **Решение для ошибок и рисков в API:**
  Внести точечные правки для корректности и устойчивости массовых операций.
  - Исправить `content_type` на `'sample'` в местах вызова логирования (например, `storage_management/api.py`) и пропустить все значения через утилиту нормализации.
  - Удалить повторяющийся блок добавления `SampleGrowthMedia` при создании образца в `collection_manager/api.py` (оставить один цикл создания связей).
  - Обернуть массовые операции (`bulk_assign_cells`) в `transaction.atomic()` и применять `select_for_update()` для ячеек/образцов; рассмотреть БД-ограничение уникальности на «один образец → одна непустая ячейка».

#### **3. Дополнительные рекомендации**
- Индексация и кеширование тяжёлых запросов:
  - Индексы: `Sample(strain_id)`, `Sample(storage_id)`, `Sample(created_at)`, `Strain(short_code)`, составной индекс `SampleCharacteristicValue(characteristic_id, boolean_value)`.
  - Кешировать агрегаты (`analytics_data`, распределения по источнику/штаммам) с TTL 1–5 минут; инвалидация при изменении сущностей.
- Тесты и стандартизация API:
  - Добавить целевые тесты для эндпоинтов `audit_logging` (позитивные кейсы, фильтры, пагинация, валидация) и для операций создания образца/массового размещения.
  - По возможности унифицировать CRUD через DRF ViewSet’ы и сократить использование `csrf_exempt`.

Файл готов для передачи специализированной модели.