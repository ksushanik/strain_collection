# План наведения порядка и перехода к микросервисам

## Цели
- Снизить сложность текущего монолита и привести код к принципам KISS, SOLID, DRY.
- Подготовить кодовую базу к постепенному выделению микросервисов без простоя бизнеса.
- Обеспечить прозрачную инфраструктуру и процессы (CI/CD, логирование, мониторинг).

## Базовые принципы
- Итеративные изменения, каждая итерация должна быть поставляема.
- Приоритет тестов и наблюдаемости перед функциональными изменениями.
- Соблюдение единой кодировки UTF-8 и единых стайлгайдов.
- Разделение доменных границ до выделения сервисов.
- **Принцип "fail fast"**: быстрое выявление проблем с возможностью отката.
- **Zero downtime**: все изменения должны происходить без остановки сервиса.

## Этап 0. Подготовка (1-2 недели)
- [ ] Провести техническую сессию: утвердить bounded context'ы, SLA, критерии готовности.
- [ ] Настроить рабочую среду: единый Makefile/скрипты, шаблон .env, lint + format хуки.
- [ ] Заполнить базу знаний: README по запуску, архитектурная диаграмма текущей системы.
- [ ] Включить базовые тесты (pytest + coverage) с pipeline в CI.
- [ ] **Создать детальную карту зависимостей между доменами (штаммы ↔ образцы ↔ хранилище).**
- [ ] **Определить критерии успешности для каждого этапа (покрытие тестами, время отклика, uptime).**
- [ ] **Подготовить план откатов для каждого этапа с четкими триггерами.**
- [ ] **Создать baseline метрик производительности текущей системы.**

### Критерии готовности Этапа 0:
- ✅ Покрытие тестами > 70% для критичных компонентов
- ✅ Настроен CI/CD pipeline с автоматическими проверками
- ✅ Документированы все зависимости между компонентами
- ✅ Команда обучена новым процессам разработки

## Этап 1. Оздоровление монолита (4-6 недель)
### Backend
- [ ] Разбить collection_manager на приложения: catalog, samples, storage, analytics.
- [ ] Перевести REST на DRF viewsets/serializers, удалить inline Pydantic.
- [ ] Вынести бизнес-логику в сервисные классы и слой репозиториев.
- [ ] Обернуть raw SQL в query-сервисы или ORM, покрыть критичные кейсы тестами.
- [ ] Нормализовать настройки: settings/base.py, dev.py, prod.py, конфигурация через env.
- [ ] Исправить кодировку строк и комментариев на UTF-8.
- [ ] **Добавить интеграционные тесты для всех API endpoints.**
- [ ] **Создать стратегию постепенной миграции с Pydantic на DRF (feature flags).**
- [ ] **Внедрить feature flags для безопасного тестирования изменений.**
- [ ] **Добавить database migrations с rollback стратегией.**

### Frontend
- [ ] Организовать структуру по фичам (features/strains, features/samples, shared).
- [ ] Разбить AddSampleForm и похожие компоненты на контейнеры и атомарные формы.
- [ ] Разделить api-клиент на модули по доменам, добавить типизацию ответов и обработку ошибок.
- [ ] Настроить unit и e2e тесты (Vitest + Playwright).
- [ ] **Добавить error boundaries для graceful degradation.**
- [ ] **Внедрить состояние загрузки и обработку сетевых ошибок.**

### Инфраструктура
- [ ] Обновить docker-compose: отдельные сервисы для frontend, backend, БД, фоновых задач.
- [ ] Добавить healthcheck и readiness-probe, логирование в единый формат.
- [ ] Ввести линтеры и форматтеры в CI, статический анализ (mypy, eslint).
- [ ] **Настроить structured logging с correlation ID.**
- [ ] **Добавить базовый мониторинг (CPU, память, время отклика).**

### Критерии готовности Этапа 1:
- ✅ Все API переведены на DRF с документацией OpenAPI
- ✅ Покрытие тестами > 80% для новых компонентов
- ✅ Время отклика API не увеличилось более чем на 10%
- ✅ Zero critical bugs в production

## Этап 2. Проектирование сервисных границ (2-3 недели)
- [ ] Описать доменные контракты (OpenAPI/JSON Schema) для каждого контекста.
- [ ] Сформировать roadmap миграций данных и определить источники истины.
- [ ] Выбрать транспорт и паттерн интеграции (REST + события через RabbitMQ или Kafka).
- [ ] Подготовить общие компоненты: единая авторизация, аудит, трассировка (OpenTelemetry).
- [ ] **Спроектировать схему версионирования API (semantic versioning + deprecation policy).**
- [ ] **Определить стратегию обработки распределенных транзакций (Saga pattern).**
- [ ] **Создать детальный план миграции данных с rollback стратегией.**
- [ ] **Спроектировать event schema и backward compatibility.**
- [ ] **Определить SLA для каждого сервиса (latency, availability, throughput).**

### Критерии готовности Этапа 2:
- ✅ Все API контракты задокументированы и согласованы
- ✅ Стратегия миграции данных протестирована на копии production
- ✅ Event schema определены с версионированием
- ✅ Команда обучена работе с распределенными системами

## Этап 3. Постепенное выделение микросервисов (6-10 недель)
- [ ] Пилот: storage-service с собственной БД, синхронизация через события.
- [ ] Развернуть API-gateway/BFF, маршрутизация запросов, агрегация данных.
- [ ] Перенести samples-service, затем catalog-service, analytics-service, media-service.
- [ ] Настроить CI/CD на каждый сервис, окружения staging и production.
- [ ] Включить централизованный мониторинг (Prometheus/Grafana) и логирование (ELK или Opensearch).
- [ ] **Добавить canary deployment для каждого сервиса (5% → 25% → 50% → 100%).**
- [ ] **Внедрить distributed tracing с самого начала (Jaeger/Zipkin).**
- [ ] **Создать runbook для каждого сервиса (troubleshooting, scaling, recovery).**
- [ ] **Настроить автоматические rollback при деградации метрик.**
- [ ] **Добавить chaos engineering тесты для проверки resilience.**

### Критерии готовности Этапа 3:
- ✅ Каждый сервис имеет независимый CI/CD pipeline
- ✅ SLA соблюдаются для всех сервисов
- ✅ Distributed tracing покрывает все межсервисные вызовы
- ✅ Автоматический rollback работает корректно

## Метрики успешности

### Технические метрики:
- **Производительность**: время отклика API < 200ms (95 percentile)
- **Надежность**: uptime > 99.9%, MTTR < 15 минут
- **Качество кода**: покрытие тестами > 85%, zero critical vulnerabilities
- **Deployment**: время деплоя < 10 минут, success rate > 99%

### Бизнес метрики:
- **Time to market**: сокращение времени разработки новых фич на 30%
- **Developer experience**: время onboarding новых разработчиков < 2 дней
- **Operational overhead**: сокращение времени на поддержку на 40%

### Мониторинг прогресса:
- Еженедельные ретроспективы с анализом метрик
- Ежемесячные архитектурные ревью
- Квартальные оценки ROI от миграции

## Параллельные инициативы
- [ ] Архитектурная документация (ADR, диаграммы C4) с регулярным обновлением.
- [ ] Политики безопасности: управление секретами, контроль доступа, бэкапы.
- [ ] Обучение команды новым практикам (Domain-Driven Design, event-driven подход).
- [ ] **Создание центра компетенций по микросервисам.**
- [ ] **Регулярные tech talks и knowledge sharing сессии.**
- [ ] **Автоматизация инфраструктуры (Infrastructure as Code).**

## Риски и меры

### Технические риски:
- **Рост технического долга при недостатке тестов** → обязательные тесты перед рефакторингом.
- **Несогласованность сервисных границ** → регулярные воркшопы и ревью архитектуры.
- **Сложность эксплуатации микросервисов** → автоматизация инфраструктуры и IaC.
- **Деградация производительности** → continuous performance testing и alerting.
- **Data consistency issues** → тщательное тестирование distributed transactions.

### Операционные риски:
- **Недостаток экспертизы команды** → инвестиции в обучение и менторинг.
- **Увеличение operational overhead** → автоматизация мониторинга и deployment.
- **Vendor lock-in** → использование open-source решений где возможно.

### Планы митигации:
- **Rollback strategy**: автоматический откат при деградации ключевых метрик
- **Circuit breaker pattern**: защита от каскадных отказов
- **Graceful degradation**: система должна работать даже при отказе отдельных сервисов
- **Regular disaster recovery drills**: ежемесячные тесты восстановления

## Контрольные точки

### Еженедельно:
- Ревью прогресса по метрикам
- Анализ инцидентов и lessons learned
- Планирование следующих задач

### Ежемесячно:
- Архитектурное ревью
- Оценка технического долга
- Корректировка планов при необходимости

### По завершении каждого этапа:
- Go/No-Go решение для следующего этапа
- Ретроспектива и документирование lessons learned
- Обновление планов на основе полученного опыта
