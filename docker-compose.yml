services:
  db:
    image: postgres:14-alpine
    container_name: strain_db
    restart: unless-stopped
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups # Для выгрузки бэкапов на хост
    env_file:
      - .env
    environment:
      - POSTGRES_DB=${POSTGRES_DB:-strain_db}
      - POSTGRES_USER=${POSTGRES_USER:-strain_user}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD} # Секрет должен быть только в .env
      - TZ=${TZ:-Europe/Moscow}
    ports:
      - "5433:5432"
    networks:
      - strain_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: strain_backend
    restart: unless-stopped
    volumes:
      - ./backups:/app/backups
      - ./data:/app/data:ro
      - ./logs:/app/logs
      - ./scripts:/app/scripts:ro
    env_file:
      - .env
    environment:
      - POSTGRES_HOST=db
      - POSTGRES_PORT=5432
      - POSTGRES_DB=${POSTGRES_DB:-strain_db}
      - POSTGRES_USER=${POSTGRES_USER:-strain_user}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD} # Секрет должен быть только в .env
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY} # Секрет должен быть только в .env
      - DJANGO_DEBUG=${DJANGO_DEBUG:-False}
      - DJANGO_ALLOWED_HOSTS=${DJANGO_ALLOWED_HOSTS:-localhost,127.0.0.1,0.0.0.0}
      - TZ=${TZ:-Europe/Moscow}
    depends_on:
      db:
        condition: service_healthy
    networks:
      - strain_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    # Логика запуска вынесена в entrypoint.sh для чистоты и удобства поддержки
    # Не забудьте добавить `COPY entrypoint.sh .` и `ENTRYPOINT ["/app/entrypoint.sh"]` в ваш backend/Dockerfile
    command: /app/entrypoint.sh
    logging:
      driver: "json-file"
      options:
        max-size: "20m" # Логи Gunicorn могут быть больше
        max-file: "5"

  nginx:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: strain_frontend_nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./data/certbot/conf:/etc/letsencrypt:ro
      - ./data/certbot/www:/var/www/certbot:ro
      - ./logs:/var/log/nginx
    extra_hosts:
      - "host.docker.internal:host-gateway"
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - strain_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/api/health/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    # Команда достаточно проста, чтобы оставить ее здесь, но для консистентности можно тоже вынести в скрипт
    command: /bin/sh -c "nginx -t && nginx -g 'daemon off;'"
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  certbot:
    image: certbot/certbot:v2.8.0 # Закрепляем версию для стабильности
    container_name: strain_certbot
    restart: unless-stopped
    volumes:
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
    networks:
      - strain_network
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew --webroot --webroot-path=/var/www/certbot --email admin@example.com --agree-tos --no-eff-email; sleep 12h & wait $${!}; done;'"

volumes:
  postgres_data:
    driver: local

networks:
  strain_network:
    driver: bridge